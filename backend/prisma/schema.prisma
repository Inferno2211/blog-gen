// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum ArticleStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
  PENDING
  GENERATED
  FLAGGED_BY_AI
  APPROVED_BY_AI
}

enum BacklinkReviewStatus {
  PENDING_REVIEW
  APPROVED
  REJECTED
}

enum ArticleAvailabilityStatus {
  AVAILABLE
  SOLD_OUT
  PROCESSING
}

enum PurchaseSessionStatus {
  PENDING_AUTH
  AUTHENTICATED
  PAYMENT_PENDING
  PAID
  PROCESSING
  COMPLETED
  FAILED
}

enum OrderStatus {
  PROCESSING
  QUALITY_CHECK
  ADMIN_REVIEW
  COMPLETED
  FAILED
  REFUNDED
}

model Domain {
  id            String   @id @default(uuid()) @db.Uuid
  slug          String   @unique
  name          String
  url           String?
  tags          String?
  categories    String?  // Comma-separated categories (e.g., "technology,business,finance")
  domain_age    Int?     // Domain age in years
  domain_rating Float?   // Domain rating/SEO value (0-100 scale)
  created_at    DateTime @default(now()) @db.Timestamptz

  articles                  Article[]
  generation_requests       ArticleGenerationRequest[]
}

model Article {
  id                   String         @id @default(uuid()) @db.Uuid
  domain_id            String?         @db.Uuid
  slug                 String         @unique
  status               String
  created_at           DateTime       @default(now()) @db.Timestamptz
  updated_at           DateTime       @updatedAt @db.Timestamptz
  backlink_expiry_date DateTime?      @db.Timestamptz
  user                 String?
  topic                String?
  niche                String?
  keyword              String?
  backlink_target      String?
  anchor               String?
  
  // Purchase system fields
  availability_status  ArticleAvailabilityStatus @default(AVAILABLE)
  pending_backlink_count Int @default(0)
  last_backlink_added  DateTime? @db.Timestamptz
  
  // Expiration & Reversion fields
  original_version_id  String?        @db.Uuid
  active_order_id      String?        @db.Uuid

  domain               Domain?         @relation(fields: [domain_id], references: [id], onDelete: Cascade)

  // selected version (1:1)
  selected_version_id String? @db.Uuid @unique
  selected_version    ArticleVersion? @relation("SelectedVersion", fields: [selected_version_id], references: [id])

  // all versions (1:many)
  versions             ArticleVersion[] @relation("AllVersions")
  
  // purchase sessions and orders
  purchase_sessions    PurchaseSession[]
  orders              Order[]
  generation_requests ArticleGenerationRequest[]

  @@map("articles")
}

model ArticleVersion {
  id               String   @id @default(uuid()) @db.Uuid
  article_id       String   @db.Uuid
  version_num      Int
  content_md       String   @db.Text
  qc_attempts      Int      @default(0)
  last_qc_status   String?
  last_qc_notes    Json?
  created_at       DateTime @default(now()) @db.Timestamptz
  prompt           String?

  // Backlink review fields
  backlink_review_status BacklinkReviewStatus?
  backlink_metadata     Json? // Store backlink URL, anchor text, original content hash
  review_notes          String? // Admin review notes
  reviewed_by           String? // Admin ID who reviewed
  reviewed_at           DateTime? // When it was reviewed

  // Scheduling fields
  scheduled_publish_at  DateTime? @db.Timestamptz
  scheduled_status      String?   @db.VarChar(30)  // SCHEDULED, CANCELLED, EXECUTED
  scheduled_job_id      String?   @db.VarChar(255) @unique
  scheduled_by          String?   // Email or session ID

  // main article this version belongs to
  article Article @relation("AllVersions", fields: [article_id], references: [id], onDelete: Cascade)

  // optional back-reference for selected version (can be omitted if not needed)
  selected_for Article? @relation("SelectedVersion")
  
  // orders that reference this version
  orders Order[]

  @@unique([article_id, version_num])
  @@index([scheduled_publish_at])
  @@map("article_versions")
}

model Admin {
  id         String   @id @default(uuid()) @db.Uuid
  email      String   @unique
  password   String   // bcrypt hashed
  name       String?
  created_at DateTime @default(now()) @db.Timestamptz
  updated_at DateTime @updatedAt @db.Timestamptz
  last_login DateTime? @db.Timestamptz

  @@map("admins")
}

model PurchaseSession {
  id                    String                @id @default(uuid()) @db.Uuid
  email                 String
  article_id            String?               @db.Uuid  // LEGACY: Keep for backward compatibility during transition
  backlink_data         Json?                 // LEGACY: Keep for backward compatibility
  cart_items            Json?                 // NEW: Array of { articleId, backlinkData: { keyword, target_url, notes } }
  purchase_type         String                @default("BACKLINK") // "BACKLINK" or "ARTICLE_GENERATION"
  status                PurchaseSessionStatus @default(PENDING_AUTH)
  stripe_session_id     String?
  magic_link_token      String                @unique
  magic_link_expires    DateTime              @db.Timestamptz
  created_at            DateTime              @default(now()) @db.Timestamptz
  updated_at            DateTime              @updatedAt @db.Timestamptz

  // Relations
  article               Article?              @relation(fields: [article_id], references: [id], onDelete: Cascade)
  orders                Order[]

  @@map("purchase_sessions")
}

model Order {
  id                    String      @id @default(uuid()) @db.Uuid
  session_id            String      @db.Uuid
  session_type          String      @default("PURCHASE") // "PURCHASE" or "GENERATION"
  article_id            String      @db.Uuid
  version_id            String?     @db.Uuid  // Created after backlink integration
  customer_email        String
  backlink_data         Json        // { keyword, target_url, notes? }
  payment_data          Json        // { stripe_session_id, amount, currency, status }
  stripe_session_id     String?     // Direct field for idempotency checks
  status                OrderStatus @default(PROCESSING)
  created_at            DateTime    @default(now()) @db.Timestamptz
  completed_at          DateTime?   @db.Timestamptz
  updated_at            DateTime    @updatedAt @db.Timestamptz

  // Scheduling fields (mirrored from ArticleVersion)
  scheduled_publish_at  DateTime? @db.Timestamptz
  scheduled_status      String?   @db.VarChar(30)  // SCHEDULED, CANCELLED, EXECUTED

  // Relations
  session               PurchaseSession? @relation(fields: [session_id], references: [id], onDelete: Cascade)
  article               Article         @relation(fields: [article_id], references: [id], onDelete: Cascade)
  version               ArticleVersion? @relation(fields: [version_id], references: [id], onDelete: SetNull)

  // Unique constraint: One order per article per Stripe session
  @@unique([stripe_session_id, article_id])
  @@map("orders")
}

model ArticleGenerationSession {
  id                    String                @id @default(uuid()) @db.Uuid
  email                 String
  generation_requests   Json                  // Array of { domainId, topic, niche, keyword, targetUrl, anchorText, notes, price }
  total_articles        Int                   @default(0)
  total_price           Decimal               @db.Decimal(10, 2)
  status                PurchaseSessionStatus @default(PENDING_AUTH)
  stripe_session_id     String?               @unique
  magic_link_token      String                @unique
  magic_link_expires    DateTime              @db.Timestamptz
  created_at            DateTime              @default(now()) @db.Timestamptz
  updated_at            DateTime              @updatedAt @db.Timestamptz

  @@map("article_generation_sessions")
}

model ArticleGenerationRequest {
  id                    String   @id @default(uuid()) @db.Uuid
  session_id            String   @db.Uuid
  domain_id             String   @db.Uuid
  topic                 String
  niche                 String?
  keyword               String?
  target_url            String   // Customer's backlink URL
  anchor_text           String   // Customer's anchor text
  notes                 String?
  price                 Decimal  @db.Decimal(10, 2)
  article_id            String?  @db.Uuid  // Created after article generation starts
  order_id              String?  @db.Uuid  // Linked order
  status                String   @default("PENDING") // PENDING, PROCESSING, COMPLETED, FAILED
  created_at            DateTime @default(now()) @db.Timestamptz
  updated_at            DateTime @updatedAt @db.Timestamptz

  // Relations
  domain                Domain   @relation(fields: [domain_id], references: [id], onDelete: Cascade)
  article               Article? @relation(fields: [article_id], references: [id], onDelete: SetNull)

  // Unique constraint: Prevent duplicate article generation on same domain+topic in same session
  @@unique([session_id, domain_id, topic])
  @@map("article_generation_requests")
}
